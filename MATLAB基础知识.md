
#MATLAB基础知识
##2.1 数据类型
###2.1.1数值类型
####1.整数类型

| 数据格式      | 示例                    |  说明  |  
| --------  | -----:                     | :----: | 
|    int8,uint8,int16,uint16,int32,uint32,int64,uint64      |int32(820) |   有符号和无符号的整数类型 相同数值的整数类型占用比浮点类型更少的内存 除了int64和uint64类型外的所有整数类型，都可以进行数学运算
|    single     |single(128.1) |单精度浮点数  相同数值的单精度浮点数占用内存比双精度少  精度与能够表示的数值范围比双精度浮点类型小   | 
|    double  |333.77  1.000-1.00i      |     双精度浮点数，MATLAB默认的数值类型 |


MATLAB默认数值类型是双精度浮点类型，将变量设置为整数类型的时候，需要用相应的转换函数，将双精度浮点数转换为指定的整数类型。

默认将带转换的数值转换为与之最接近的整数，


#####MATLAB中的取整函数


| 函数      | 运算法则                      |  示例  |
| --------  | -----:                      | :----: |
|    floor(x)  |向下取整              |floor(1.2)=1  floor(2.5)=2 floor(-2.5)=-3    |
|    ceil(x)    |向上取整 |ceil(1.2)=2;ceil(-2.5)=-2  | 
|    round(x)     |取最接近的整数，如果小数部分是0.5，则向绝对值最大的方向取整       |     round(1.2)=1;roud(-2.5)=-3|
|    fix(x)   | 向0取整                |fix(1.2)=1;fix(2.5)=2;fix(-2.5)=-2   | 

####浮点数类型


| 浮点类型      | 存储位宽                    |  各数位的意义  |  数值范围  |
| --------  | -----:                     | :----: | :----: |
|    单精度     |32  |0-22位表示小数部分，23-30表示指数部分；31位表示符号（0正1负）   |      |
|    双精度    |64 |0-51位表示小数部分；52-62位表示指数部分，63位表示符号   | |

双精度浮点数参与运算时，返回值的类型依赖于参与运算的其他数据类型。逻辑型，字符型，返回为双精度浮点数；整数型，返回为相应的整数型；单精度浮点数时，返回为相应的单精度浮点数


**在MATLAB中单精度浮点数不能与整数类型进行算术运算。**

####复数
MATLAB默认用i或j作为虚部标志

与复数相关的函数


| 函数      | 说明                    |  函数  |  说明  |
| --------  | -----:   | :----: | :----: |
|    real(z) |返回复数的实部|imag(z)    |返回复数z的虚部      |
|    abs(z)  |返回复数的模 |angel(z)| 返回复数z的辐角         |
|    conj(z) |返回复数z的共轭复数 | complex(a,b) |以a为实部，b为虚部创建复数      |




####无穷量（Inf）非数值量（NaN）
MATLAB中使用Inf和-Inf分别代表证无穷量和负无穷两，NaN表示非数值量。
正负无穷量产生一般是由于运算溢出，产生了超出双精度浮点数数值范围的结果，非数值量则是由于0/0或Inf/Inf类型的非正常运算而产生的，这两个NaN彼此是不相等的。

####2.1.2逻辑类型
作为所有关系和逻辑表达式的输入，MATLAB把任何非零数值当做真，把零当作假；所有关系和逻辑表达式的输出：对于真，输出为1，对于假输出为0.

MATLAB关系操作符能用来比较两个同样大小的数组，或用来比较一个数组和一个标量。在后一种情况中，标量和数组中的每一个元素相比较，结果与数组大小一样。

MATLAB的关系操作符


| 关系操作符       | 说明                    |  
| --------  | -----:                     | 
|    <      |              |
|    <=     | |
|    >     |       |  
|    >=    |                  |
|    ==   |                  | 
|    ~=    |             |






例：判断两个数组之间的元素是否相等。

在命令行输入：

A = 1：9；B = 10-A

A = 
   1 2 3 4 5 6 7 8 9

B = 
   9 8 7 6 5 4 3 2 1
   
在命令行窗口输入：
   
   TureorFalse = （A == B）
   
输出结果：
   
   TureorFalse =
   
   0 0 0 0 1 0 0 0 0

**逻辑运算符**

| 逻辑运算符  | 说明   |  
| --------  | -----: |
|    &      |   与   |
|     \|    |   或   | 
|    ~      |   非   |  

例子：判断一个数组里的元素是否在2~6之间

A = 1:9;
   
   TrueorFalse = （A>2）&（A<6）
   
   TrueorFalse = 
   
   0 0 1 1 1 0 0 0 0
   
   易或运算：xor（x,y）:x和y同为零（假）或非零（真）时返回0，否则返回1.
   
   any(y):判断是否为零向量或零矩阵，如果是零向量或零矩阵返回1，否则返回0
   
  **测试函数** 

| 函数名称  | 函数功能   |  
| --------  | -----: |
|    finite      |元素有限，返回真值      |
|    isempty     |参数为空，返回真值      | 
|    isglobal    |参量是一个全局变量，返回真值      | 
|    ishold      |当前图形保持状态是”ON“，返回真值      |
|    isieee      |      | 
|    isinf      |      | 
|    isletter      |      |
|    isnan      |      | 
|    isreal      |      | 
|    isspace      |      |
|    isstr      |      | 

         

###2.1.3字符和字符串

MATLAB中字符和字符串是存储在一个行向量中的，这个行向量中的每一个元素代表一个字符。实际上，元素中存放的是字符内部的ASCII码。

因为字符串是以一个向量存储的，所以可以用它的下标对任何一个元素进行访问。每个字符存储用的是八个字节。

例子：

```
String = 'Every good boy does fun.';

ans = 
      1 24
      
whos 
     Name Size Bytes Class Attributes
     ans  1*2  16    double
     String 1*24 48 char 
     
     
String（5）=
         y  
String（6）=
           

String（24）=
          .
 % 空格与标点也是占一个数组的元素，所以一共有24个元素
 
 % whos命令用于查看变量的属性
 
```
 

同样，因为字符串是数值数组，可以利用MATLAB中的数组操作工具对它进行操作。

例：

```
   String = 'Every good boy does fun.';
   U =String(7:10)
   U = 
      good
      
   U = String(10:-1:1)
   U =
      doog
```
      
 字符串中的单引号
 
 String=’it’'s not the manual‘


字符串的连接可以直接将字符串数组连接来实现。



```
U = 'Hello，'；

V = ‘world！’；

W = [u v]

w =
   Hello,world!
```

###2.1.4函数句柄

函数句柄（Function handle）是MATLAB的一种特殊的数据类型，它的地位类似于其它计算机语言里的函数对象，相当于给函数起一个代号，调用时可以直接调用代号。

问：f=@(x)acos(x)表示什么意思？其中@代表什么？

答：表示f为函数句柄，@是定义句柄的运算符。f=@(x)acos(x) 相当于建立了一个函数文件：

% f.m

function  y=f(x)

y=acos(x);

若有下列语句：xsqual=@(x)1/2.*(x==-1/2)+1.*(x>-1/28&x<1/2)+1.2.*(x==-1/2);

则相当于建立了一个函数文件：

% xsqual.m

function y=xsqual(x)

y=1/2.*(x==-1/2)+1.*(x>-1/28&x<1/2)+1.2.*(x==-1/2);

详细说明：

1、函数句柄/function_handle(@)：是一种间接调用函数的方式。

2、语法：handle=@functionname  or handle=@(arglist)anonymous_function

3、描述：函数句柄（function handle）是一种能够提供函数间接调用的matlab value。你可以通过传递句柄来调用各种其他功能。你也可以将句柄存储到数据结构中备用（例如Handle Graphic 回调）。句柄是matlab的标准数据类型之一。

  当创建句柄时，你所指定的函数必须在matlab搜索路径之中，并且必须在创建语句的scope之中。例如，只要在定义子函数的文件之中，你句可以为这个子函数创建句柄。这些条件不适用于evaluate函数句柄。例如，你可以在一个单独（out-scope）通过句柄执行一个子函数，这要求句柄是在in-scope创建的。
       
   handle=@(arglist)anonymous_function用来创建匿名函数（anonymous function）并返回该匿名函数的句柄。括号右边的函数体是单个的matlab语句(statement)或者matlab命令。arglist是一个用逗号“，”分隔的输入变量列表。该函数通过句柄handle执行。

备注：函数句柄是标准的matlab数据类型。因此，你可以像matlab其他数据类型一样进行操作。

   
            
      
      
      
**函数句柄的好处**
       
   ①提高运行速度。因为matlab对函数的调用每次都是要搜索所有的路径，从set path中我们可以看到，路径是非常的多的，所以如果一个函数在你的程序中需要经常用到的话，使用函数句柄，对你的速度会有提高的。
   ②使用可以与变量一样方便。比如说，我再这个目录运行后，创建了本目录的一个函数句柄，当我转到其他的目录下的时候，创建的函数句柄还是可以直接调用的，而不需要把那个函数文件拷贝过来。因为你创建的function handles中，已经包含了路径


**函数句柄的操作符**

| 函数名称  | 函数功能   |  
| --------  | -----: |
|    functions(funhandle)      |   返回一个结构体，存储了函数的名称，函数类型（simple或overload），以及函数M文件的位置   |
|    func2str(funhandle)     |   将函数句柄转换为函数名称的字符串   | 
|    str2func（str）      |   将字符串代表的函数转换为函数句柄   |
|    save filename.mat funhandle  | 将函数句柄保存在*.mat文件中   |  
|    load filename.mat funhandle  | 将*.mat存储的函数句柄加载到工作区 |
|    isa(var,'function_handle')    |   检测变量var是否是函数句柄   |
|    iseual(funhandlea,funhandleb)     |   两个函数句柄是否对应同一个函数   | 

###2.1.5 结构体类型（struct）

结构体相当于一个数据容器，把相关联的不同类型的数据封装在一个结构体对象中。

比如结构体student可以有四个字段，分别是年级字段grade存储一个浮点数值；科目字段subject中存储了一个字符串类型数据，成绩字段存储了一个一维数组。

创建结构体对象的方法：

（1）直接对字段赋值

在命令行输入：

Student.Name = 'Sam';

Student.Grade = 6;

Student.Subject = {'chinese','math','english'};

Student.Result = {99,99,99};

Student

输出结果：

Student =
    Name：‘Sam’
    Grade：6
    Subject：{1*3 cell}
    Result：{[99] [99] [99]}
    
在命令行输入：
    whos
    
输出结果：

Name      Size   Bytes Class      Attribites
Student   1*1    930              struct


（2）用struct函数创建结构体

StrArray = struct（‘field’,var1,'file2',var2,...,'fieldn',varn）


###数组类型


在MATLAB中进行的所有数据类型，都是按照数组及矩阵的形式进行运算和存储的。

数组的定义很广，数组的元素可以是任何数据类型，数值，字符串，指针等。

构建数组方法：
（1）对变量赋值
  A = [1 2 3 4 5 6 7 8]


（2）冒号  Arry = i:k 从i开始到k结束（包含i和j）,步长为1.

(3)Arry = i:j:k 从i开始到k结束（包含i和j）,步长为k.

(4)Arry = linspace(a,b,100)  在[a,b]之间创建一个有100个元素的向量。


当数组的元素为0时，称数组为空。

###2.1.7单元数组类型（cell）

单元数组的特点是组成它的每一个单元可以是任意的数组，比如数值数组，字符串数组、结构体数组或另外一个单元数组，不同类型的数据都可以整合到一个数组内。

单元数组使用花括号”{}“来创建，使用逗号”，“或空格来分割每个单元，用分号”；“来分行。

**创建单元数组**
1.概述
(1)直接赋值

C = {'x',[1;2;3];10,pi}

（2）创建空单元数组

cellName = cell（m,n） 创建m*n的空单元数组。

创建空单元数组的主要目的是为该单元数组预先分配连续的存储空间，以节约内存占用，提高执行效率。

2.单元数组的寻访  

寻访单元和单元中的内容是两个不同的操作，分别对应两个不同的操作：
单元外标识（Cell Indexing）和单元内编址（Content Addressing）

对于单元组C，C(m,n)指的是单元数组中第m行n列的单元，C{m,n}指的是单元数组中第m行n列的单元内容。

3.单元数组的操作


###map容器类型

1.map容器类型及map类概述

map是映射，比如将一个字符串映射为一个数值，字符串即为map的键（key），数值即为map的数据（value）。可将map容器理解为一个快速查找数据结构的键。


对一个map元素进行寻访的索引称为”键“。一个键可以是

* 1*N 的字符串
* 单精度或双精度实数标量
* 有符号或无符号的标量整数

  
一个map是MATLAB类的一个对象，map类的所有对象具有三种属性。

| 属性      | 说明                    |  默认值  |  
| --------  | -----:                     | :----: | 
|    Count  |无符号64位整数，表示map对象中存储的key/value对的总数 |   0|    
|KeyType |字符串，表示map对象中包括的key的类型   |char 
|    ValueType  |字符串，表示map对象中包括的数据类型      |     any |

2.创建map对象

map01 = containers.Map（{key1,key2,...}，{val1,val2,...}）

当键和数值是字符串时，需要对语法作出更改：

map01 = containers.Map({'key1','key2'，...},{val1,val2,...})


例：创建一个名为schedulemap的map对象来存储下面的课表。

| 星期一      | 星期二 |  星期三  |  星期四|星期五
| --------  | ----- | ---- |-----|------| -----: | :----: | 
| 数学     | 语文|历史|地理|生物| 

```
   schedulemap = containers.Maps({'星期一','星期二','星期三','星期四','星期五'},{’数学‘，’语文‘，’历史‘，’地理‘，’生物‘})
   
   
   schedulemap=
      Map(带属性):
          count：5
          KeyType；char
          ValueType：char

```

此外还可以先创建一个空map对象

newmap = container.Maps()


3.查看/读取map对象

**查看**

keys（schedulemap）

values（schedulemap）

**读取**

valuename = mapname（keyname）


对多个键进行访问：

values（schedulemap，{’Monday‘，’Thursday‘}）

4.编辑map对象

（1）从map对象中删除keys/values对

remove（’mapname‘，’keyname‘）

（2）添加keys/values对象

（3）修改keys

 (4)修改values
 
##基本矩阵操作
###2.2.1矩阵和数组的概念及区别

对矩阵的基本操作，主要有矩阵的构建、矩阵维度与矩阵大小的改变、矩阵的索引、矩阵属性信息的获取、矩阵结构的改变等。

矩阵的定义

行向量

列向量


数组是在程序设计中，为处理方便，把具有相同类型的若干变量按有序的形式组织起来的一种形式，这些排列的同类数据元素的合集称为数组。


按数组元素的类型不同，数组可分为数值数组、字符数组、单元数组、结构数组等类别

矩阵与数组的区别：

* 矩阵是数学上的概念，数组是计算机程序设计领域的概念。
* 作为一种变换或者映射算符的体现，矩阵运算有着明确而严格的数学规则。而数组运算是MATLAB软件定义的规则，其目的是为了使数据管理方便，操作简单，命令形式自然，执行计算有效。
* 两者此间的联系在于，在MATLAB中矩阵是以数组的形式存在的。一维数组相当于向量，二维数组相当于矩阵，矩阵是数组的子集。

###2.2.2矩阵的构造

矩阵的构造方式：一是直接赋值；二是用特殊矩阵指令

**特殊矩阵的构建函数**

| 函数名称  | 函数功能   |  
| --------  | -----: |
|    ones(n)        |      |
|    ones(m,n...p)     |构建一个m\*n\*...*p的1矩阵      | 
|    ones(size(A))    |构建一个和矩阵A同样大小的1矩阵      | 
|    zeros(n)          |      |
|    zeros(m,n...p)    |      | 
|    zeros(size(A))    |      | 
|    eye(n)            |      |
|    eye(m,n)          |      | 
|    eye(size(A))      |      | 
|    magic(n)          |  构建一个n\*n矩阵，每一行、每一列的元素之和都相等    |
|    rand(n)           |  构建一个n\*n矩阵，其元素为0~1之间均匀分布的随机数    | 
|    rand(m,n...p)     |      | 
|    randn(n)          |  构建一个n\*n矩阵，其元素为零均值，单位方差的正态分布随机数      | 
|    rand(m,n,...,p)   |      | 
|    diag(x)           |  构建一个n维矩阵，它的主对角线元素取自向量x,其余元素值都为0    | 
|    diag(x,k)         |  构建一个由矩阵A第k条d    | 
|    triu(A)           |      | 
|    triu(A,k)         |      |
|    tril(A)           |      | 
|    tril(A,k)         |      |





**[关于diag矩阵的说明](http://blog.csdn.net/porly/article/details/7872313)**


关于matlab中的diag函数（矩阵对角元素的提取和创建对角阵）

diag函数功能：矩阵对角元素的提取和创建对角阵

设以下X为矩阵，v为向量

1、X = diag(v,k) 当v是一个含有n个元素的向量时，返回一个n+abs(k)阶方阵X，向量v在矩阵X中的第k个对角线上，k=0表示主对角线，k>0表示在主对角线上方，k<0表示在主对角线下方。

例1：

v=[1 2 3];

diag(v, 3)

ans =

     0     0     0     1     0     0
     0     0     0     0     2     0
     0     0     0     0     0     3
     0     0     0     0     0     0
     0     0     0     0     0     0
     0     0     0     0     0     0

注：从主对角矩阵上方的第三个位置开始按对角线方向产生数据的

例2：

v=[1 2 3];
diag(v, -1)
ans =
      0 0 0 0
      1 0 0 0
      0 2 0 0
      0 0 3 0

注：从主对角矩阵下方的第一个位置开始按对角线方向产生数据的

2、X = diag(v)

向量v在方阵X的主对角线上，类似于diag(v,k),k=0的情况。
例3：

v=[1 2 3];
diag(v)

ans =

1 0 0
0 2 0
0 0 3

注：写成了对角矩阵的形式

 3、v = diag(X,k)

返回列向量v，v由矩阵X的第k个对角线上的元素形成

例4：

 v=[1 0 3;2 3 1;4 5 3];

 diag(v,1)

 ans =

     0
     1

注：把主对角线上方的第一个数据作为起始数据，按对角线顺序取出写成列向量形式

4、v = diag(X)返回矩阵X的主对角线上的元素，类似于diag(X,k)，k=0的情况

例5：

v=[1 0 0;0 3 0;0 0 3];

diag(v)

ans =

1
3
3

或改为：

v=[1 0 3;2 3 1;4 5 3];

diag(v)

ans =

1
3
3

注：把主对角线的数据取出写成列向量形式

5、diag(diag(X))

取出X矩阵的对角元，然后构建一个以X对角元为对角的对角矩阵。

例6：

 X=[1 2;3 4]       
 
 
 diag(diag(X))

X =

     1     2
     3     4

 

ans =

     1     0
     0     4



**tril和triu函数**


函数  tril   %取下三角部分

格式  L = tril(X)     %抽取X的主对角线的下三角部分构成矩阵L

   L = tril(X,k)    %抽取X的第k条对角线的下三角部分；k=0为主对角线；k>0为主对角线以上；k<0为主对角线以下。

函数  triu    %取上三角部分

格式  U = triu(X)    %抽取X的主对角线的上三角部分构成矩阵U

U = triu(X,k)   %抽取X的第k条对角线的上三角部分；k=0为主对角线；k>0为主对角线以上；k<0为主对角线以下。

例

 A=ones(4)    %产生4阶全1阵

 A =
   
     1     1     1     1
     
     1     1     1     1
     
     1     1     1     1
     
     1     1     1     1

 L=tril(A,1)    %取下三角部分

L =
     1     1     0     0
     
     1     1     1     0
     
     1     1     1     1
     
     1     1     1     1

 U=triu(A,-1)    %取上三角部分

U =
     1     1     1     1
     
     1     1     1     1
     
     0     1     1     1
     
     0     0     1     1




1.建立简单的矩阵

2.建立特殊的矩阵

3.向量、标量和空矩阵

单个实数和复数在MATLAB中都是以矩阵的形式存储的

空矩阵没用任何元素，不占用任何存储空间。0矩阵表示该矩阵中全部元素为0.

###矩阵大小及结构的改变

**矩阵旋转与改变维度的函数**


| 函数名称  | 函数功能   |  
| --------  | -----: |
|    fliplr(A)            |  矩阵每一行均进行逆序排列      |
|    flipup(A)            |  矩阵每一列均进行逆序排列    | 
|    flipdim(A,dim)       |  生成一个在dim维矩阵A内的元素交换位置的多维矩阵    | 
|    rot90(A)             |  生成一个由矩阵A逆时针旋转90度得到的新矩阵    |
|    rot90(A,k)           |  生成一个由矩阵A逆时针旋转90度*k得到的新矩阵    | 
|    reshape(A,m,n)       |  生成一个m \*n \*...\*p维的矩阵，其元素以线性索引的顺序从矩阵A中获得,如果元素数量不够，返回错误信息    | 
|    rempat(A,[m n ... p])|  创建一个和矩阵A有相同元素的m\*n\*...\*p的多维矩阵    |
|    shiftdim(A,n)        |  矩阵的列移动n步，n为正数左移，负数，右移    | 
|    squeeze(A)           |  返回没有空维的矩阵A    | 
|    cat(dim,A,B)         |  将矩阵A和B组合成一个dim维的多维矩阵    |
|    permute(A,order)     |  根据向量order来改变矩阵A中的维数顺序    | 
|    ipermute(A,order)    |  进行命令permute的逆变换    | 
|    sort(A)              |  对一维或二维矩阵进行升序排序，并返回排序后的矩阵；当A为二维矩阵时，对矩阵的每一列分别进行排序      | 
|    sort(A,dim)          |  对矩阵按指定的方向进行升序排列，并返回排序后的矩阵。当dim=1时，对矩阵的每一列排序，当dim=2时，对矩阵每一行排序    | 
|    sort(A,dim,mode)     |  mode为”ascend“时，升序排序，’descend‘时，将序排列    | 
|    [B IX]= sort(A,...)  |  IX为排序后备元素在原矩阵的行位置或列位置的索引    | 





 



